"""
M√≥dulo Singleton para gerenciar conex√µes e buscas do Earth Access.
Fornece uma interface reutiliz√°vel para acessar dados do NASA Earthdata.
"""

import os
import datetime
import earthaccess
from typing import List, Optional, Tuple, Dict, Any
from dotenv import load_dotenv


class EarthAccessManager:
    """
    Singleton para gerenciar conex√µes e buscas do Earth Access.
    Garante que apenas uma inst√¢ncia seja criada e reutilizada.
    """
    
    _instance = None
    _authenticated = False
    _auth_failed = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(EarthAccessManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self._load_credentials()
            self._initialized = True
    
    def _load_credentials(self):
        """Carrega credenciais do arquivo .env"""
        load_dotenv()
        
        if not os.getenv("EARTHDATA_USERNAME") or not os.getenv("EARTHDATA_PASSWORD"):
            raise ValueError(
                "‚ùå Credenciais n√£o encontradas no arquivo .env\n"
                "Configure EARTHDATA_USERNAME e EARTHDATA_PASSWORD no arquivo .env"
            )
    
    def authenticate(self) -> bool:
        """
        Autentica com o Earth Access.
        
        Returns:
            bool: True se autentica√ß√£o bem-sucedida, False caso contr√°rio
        """
        if self._authenticated:
            return True
            
        if self._auth_failed:
            print("‚ùå Autentica√ß√£o j√° falhou anteriormente. Parando execu√ß√£o.")
            return False
            
        try:
            print("üîê Autenticando com Earthdata...")
            
            # Suprime logs duplicados do earthaccess
            import logging
            import sys
            from contextlib import redirect_stderr, redirect_stdout
            from io import StringIO
            
            # Captura e suprime todos os logs duplicados
            with redirect_stderr(StringIO()), redirect_stdout(StringIO()):
                auth = earthaccess.login(strategy="environment")
            
            if auth:
                self._authenticated = True
                print("‚úÖ Autentica√ß√£o realizada com sucesso!")
                return True
            else:
                print("‚ùå Falha na autentica√ß√£o")
                self._auth_failed = True
                return False
        except Exception as e:
            print(f"‚ùå Erro na autentica√ß√£o: {e}")
            self._auth_failed = True
            return False
    
    def search_data(
        self,
        short_name: str,
        provider: str = "OB_CLOUD",
        downloadable: bool = True,
        temporal: Optional[Tuple[str, str]] = None,
        granule_name: Optional[str] = None,
        # Par√¢metros geogr√°ficos
        bounding_box: Optional[Tuple[float, float, float, float]] = None,  # (min_lon, min_lat, max_lon, max_lat)
        polygon: Optional[List[Tuple[float, float]]] = None,  # Lista de coordenadas (lon, lat)
        point: Optional[Tuple[float, float]] = None,  # (lon, lat)
        # Par√¢metros de filtro
        cloud_cover: Optional[Tuple[float, float]] = None,  # (min, max) percentual
        day_night_flag: Optional[str] = None,  # "DAY", "NIGHT", "BOTH"
        instrument: Optional[str] = None,
        platform: Optional[str] = None,
        processing_level: Optional[str] = None,
        version: Optional[str] = None,
        # Par√¢metros de pagina√ß√£o
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        # Par√¢metros de data
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        **kwargs
    ) -> List[Any]:
        """
        Busca dados usando earthaccess.search_data com autentica√ß√£o autom√°tica.
        
        Args:
            short_name (str): Nome curto do dataset
            provider (str): Provedor dos dados (padr√£o: "OB_CLOUD")
            downloadable (bool): Se deve retornar apenas dados baix√°veis
            temporal (Tuple[str, str], optional): Tupla com data in√≠cio e fim
            granule_name (str, optional): Padr√£o do nome do granule
            
            # Par√¢metros geogr√°ficos
            bounding_box (Tuple[float, float, float, float], optional): Bounding box (min_lon, min_lat, max_lon, max_lat)
            polygon (List[Tuple[float, float]], optional): Lista de coordenadas (lon, lat) formando pol√≠gono
            point (Tuple[float, float], optional): Ponto espec√≠fico (lon, lat)
            
            # Par√¢metros de filtro
            cloud_cover (Tuple[float, float], optional): Cobertura de nuvens (min, max) em percentual
            day_night_flag (str, optional): "DAY", "NIGHT", "BOTH"
            instrument (str, optional): Nome do instrumento
            platform (str, optional): Nome da plataforma
            processing_level (str, optional): N√≠vel de processamento
            version (str, optional): Vers√£o do dataset
            
            # Par√¢metros de pagina√ß√£o
            count (int, optional): N√∫mero m√°ximo de resultados
            cursor (str, optional): Cursor para pagina√ß√£o
            
            # Par√¢metros de data alternativos
            start_time (str, optional): Data/hora de in√≠cio (formato ISO)
            end_time (str, optional): Data/hora de fim (formato ISO)
            
            **kwargs: Argumentos adicionais para earthaccess.search_data
            
        Returns:
            List[Any]: Lista de resultados da busca
            
        Raises:
            Exception: Se n√£o conseguir autenticar ou buscar dados
        """
        if not self._authenticated:
            if not self.authenticate():
                raise Exception("Falha na autentica√ß√£o com Earth Access")
        
        try:
            # Valida√ß√£o de par√¢metros geogr√°ficos
            spatial_params = [bounding_box, polygon, point]
            if sum(1 for param in spatial_params if param is not None) > 1:
                raise ValueError("Apenas um par√¢metro geogr√°fico pode ser especificado: bounding_box, polygon ou point")
            
            # Constr√≥i par√¢metros de busca
            search_params = {
                "short_name": short_name,
                "provider": provider,
                "downloadable": downloadable,
                **kwargs
            }
            
            # Adiciona par√¢metros condicionalmente
            if temporal:
                search_params["temporal"] = temporal
            if granule_name:
                search_params["granule_name"] = granule_name
            if bounding_box:
                search_params["bounding_box"] = bounding_box
            if polygon:
                search_params["polygon"] = polygon
            if point:
                search_params["point"] = point
            if cloud_cover:
                search_params["cloud_cover"] = cloud_cover
            if day_night_flag:
                search_params["day_night_flag"] = day_night_flag
            if instrument:
                search_params["instrument"] = instrument
            if platform:
                search_params["platform"] = platform
            if processing_level:
                search_params["processing_level"] = processing_level
            if version:
                search_params["version"] = version
            if count:
                search_params["count"] = count
            if cursor:
                search_params["cursor"] = cursor
            if start_time:
                search_params["start_time"] = start_time
            if end_time:
                search_params["end_time"] = end_time
            
            # Log de par√¢metros de busca
            print(f"üîç Buscando dados: {short_name}")
            if temporal:
                print(f"üìÖ Per√≠odo: {temporal[0]} a {temporal[1]}")
            if bounding_box:
                print(f"üó∫Ô∏è Bounding Box: {bounding_box}")
            if polygon:
                print(f"üî∑ Pol√≠gono: {len(polygon)} pontos")
            if point:
                print(f"üìç Ponto: {point}")
            if granule_name:
                print(f"üìÑ Padr√£o: {granule_name}")
            if cloud_cover:
                print(f"‚òÅÔ∏è Cobertura de nuvens: {cloud_cover[0]}% - {cloud_cover[1]}%")
            
            results = earthaccess.search_data(**search_params)
            print(f"‚úÖ Encontrados {len(results)} resultados")
            
            return results
            
        except Exception as e:
            print(f"‚ùå Erro na busca: {e}")
            raise
    
    def search_recent_data(
        self,
        short_name: str,
        max_days_back: int = 7,
        granule_name: str = "*DAY*.4km*",
        provider: str = "OB_CLOUD",
        # Par√¢metros geogr√°ficos
        bounding_box: Optional[Tuple[float, float, float, float]] = None,
        polygon: Optional[List[Tuple[float, float]]] = None,
        point: Optional[Tuple[float, float]] = None,
        # Outros par√¢metros
        cloud_cover: Optional[Tuple[float, float]] = None,
        day_night_flag: Optional[str] = None,
        **kwargs
    ) -> List[Any]:
        """
        Busca dados recentes dos √∫ltimos N dias.
        
        Args:
            short_name (str): Nome curto do dataset
            max_days_back (int): N√∫mero m√°ximo de dias para buscar (padr√£o: 7)
            granule_name (str): Padr√£o do nome do granule
            provider (str): Provedor dos dados
            
            # Par√¢metros geogr√°ficos
            bounding_box (Tuple[float, float, float, float], optional): Bounding box (min_lon, min_lat, max_lon, max_lat)
            polygon (List[Tuple[float, float]], optional): Lista de coordenadas (lon, lat) formando pol√≠gono
            point (Tuple[float, float], optional): Ponto espec√≠fico (lon, lat)
            
            # Outros par√¢metros
            cloud_cover (Tuple[float, float], optional): Cobertura de nuvens (min, max) em percentual
            day_night_flag (str, optional): "DAY", "NIGHT", "BOTH"
            
            **kwargs: Argumentos adicionais
            
        Returns:
            List[Any]: Lista de resultados encontrados
        """
        all_results = []
        
        # Tenta autenticar uma √∫nica vez antes de come√ßar as buscas
        if not self._authenticated:
            if not self.authenticate():
                print("‚ùå Falha na autentica√ß√£o. Parando execu√ß√£o.")
                return []
        
        for delta in range(1, max_days_back + 1):
            date = datetime.datetime.now(datetime.timezone.utc).date() - datetime.timedelta(days=delta)
            
            try:
                results = self.search_data(
                    short_name=short_name,
                    provider=provider,
                    temporal=(str(date), str(date)),
                    granule_name=granule_name,
                    bounding_box=bounding_box,
                    polygon=polygon,
                    point=point,
                    cloud_cover=cloud_cover,
                    day_night_flag=day_night_flag,
                    **kwargs
                )
                
                if results:
                    all_results.extend(results)
                    print(f"‚úÖ Encontrados {len(results)} resultados para {date}")
                else:
                    print(f"‚ÑπÔ∏è Nenhum resultado para {date}")
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao buscar dados para {date}: {e}")
                # Se for erro de autentica√ß√£o, para a execu√ß√£o
                if "autentica√ß√£o" in str(e).lower() or "authentication" in str(e).lower():
                    print("‚ùå Erro de autentica√ß√£o detectado. Parando execu√ß√£o.")
                    break
                continue
        
        return all_results
    
    def download_data(
        self,
        results: List[Any],
        local_path: str = "downloads"
    ) -> List[str]:
        """
        Baixa dados usando earthaccess.download.
        
        Args:
            results (List[Any]): Lista de resultados da busca
            local_path (str): Diret√≥rio local para salvar os arquivos
            
        Returns:
            List[str]: Lista de caminhos dos arquivos baixados
        """
        if not results:
            print("‚ö†Ô∏è Nenhum resultado para baixar")
            return []
        
        try:
            os.makedirs(local_path, exist_ok=True)
            print(f"üì• Baixando {len(results)} arquivo(s) para {local_path}...")
            
            files = earthaccess.download(results, local_path=local_path)
            print(f"‚úÖ {len(files)} arquivo(s) baixado(s) com sucesso!")
            
            return files
            
        except Exception as e:
            print(f"‚ùå Erro ao baixar dados: {e}")
            raise
    
    def is_authenticated(self) -> bool:
        """Verifica se est√° autenticado."""
        return self._authenticated
    
    def reset_authentication(self):
        """Reseta o estado de autentica√ß√£o (√∫til para testes)."""
        self._authenticated = False
        self._auth_failed = False


# Inst√¢ncia global do singleton
earth_manager = EarthAccessManager()


def get_earth_manager() -> EarthAccessManager:
    """
    Fun√ß√£o de conveni√™ncia para obter a inst√¢ncia do EarthAccessManager.
    
    Returns:
        EarthAccessManager: Inst√¢ncia singleton do gerenciador
    """
    return earth_manager
